/*
 * Copyright © 2017 Canonical Ltd.
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 or 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored By: Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>
 */

#include "wrapper_generator.h"
#include "emitter.h"
#include "argument.h"
#include "method.h"

#include <libxml++/libxml++.h>
#include <functional>
#include <vector>
#include <experimental/optional>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <locale>
#include <stdio.h>

const std::vector<std::string> cpp_reserved_keywords = {"namespace"}; // add to this on an as-needed basis

// remove the path from a file path, leaving only the base name
std::string file_name_from_path(std::string const& path)
{
    size_t i = path.find_last_of("/");
    if (i == std::string::npos)
        return path;
    else
        return path.substr(i + 1);
}

// make sure the name is not a C++ reserved word, could be expanded to get rid of invalid characters if that was needed
std::string sanitize_name(std::string const& name)
{
    std::string ret = name;
    for (auto const& i: cpp_reserved_keywords)
    {
        if (i == name)
        {
            ret = name + "_";
        }
    }
    return ret;
}

Emitter emit_comment_header(std::string const& input_file_path)
{
    return Lines{
        "/*",
        " * AUTOGENERATED - DO NOT EDIT",
        " *",
        {" * This header is generated by wrapper_generator.cpp from ", file_name_from_path(input_file_path)},
        " * To regenerate, run the “refresh-wayland-wrapper” target.",
        " */",
    };
}

// converts any string into a valid, all upper case macro name (replacing special chars with underscores)
std::string macro_string(std::string const& name)
{
    std::string macro_name = "";
    for (unsigned i = 0; i < name.size(); i++)
    {
        char c = name[i];
        if ((c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= '0' && c <= '9' && i > 0))
        {
            macro_name += std::toupper(c, std::locale("C"));
        }
        else
        {
            macro_name += '_';
        }
    }
    return macro_name;
}

Emitter emit_include_guard_top(std::string const& macro)
{
    return Lines{
        {"#ifndef ", macro},
        {"#define ", macro},
    };
}

Emitter emit_include_guard_bottom(std::string const& macro)
{
    return Lines{
        {"#endif // ", macro}
    };
}

Emitter emit_required_headers(std::string const& custom_header)
{
    return Lines{
        "#include <experimental/optional>",
        "#include <boost/throw_exception.hpp>",
        "#include <boost/exception/diagnostic_information.hpp>",
        "",
        {"#include \"", custom_header, "\""},
        "",
        "#include \"mir/fd.h\"",
        "#include \"mir/log.h\"",
    };
}

std::string camel_case_string(std::string const& name)
{
    std::string camel_cased_name;
    camel_cased_name = std::string{std::toupper(name[0], std::locale("C"))} + name.substr(1);
    auto next_underscore_offset = name.find('_');
    while (next_underscore_offset != std::string::npos)
    {
        if (next_underscore_offset < camel_cased_name.length())
        {
            camel_cased_name = camel_cased_name.substr(0, next_underscore_offset) +
                               std::toupper(camel_cased_name[next_underscore_offset + 1], std::locale("C")) +
                               camel_cased_name.substr(next_underscore_offset + 2);
        }
        next_underscore_offset = camel_cased_name.find('_', next_underscore_offset);
    }
    return camel_cased_name;
}

void emit_indented_lines(std::ostream& out, std::string const& indent,
                         std::initializer_list<std::initializer_list<std::string>> lines)
{
    for (auto const& line : lines)
    {
        out << indent;
        for (auto const& fragment : line)
        {
            out << fragment;
        }
        out << "\n";
    }
}

class Interface
{
public:
    Interface(
        xmlpp::Element const& node,
        std::function<std::string(std::string)> const& name_transform,
        std::unordered_set<std::string> const& constructable_interfaces)
        : wl_name{node.get_attribute_value("name")},
          generated_name{name_transform(wl_name)},
          is_global{constructable_interfaces.count(wl_name) == 0},
          methods{get_methods(node, is_global)},
          has_vtable{!methods.empty()}
    {
    }

    Emitter full_class()
    {
        return Lines{
            {"class ", generated_name},
            "{",
            "protected:",
            constructor(),
            destructor(),
            (is_global ? bind_prototype() : nullptr),
            virtual_method_prototypes(),
            member_vars(),
            "private:",
            thunk_bodies(),
            (is_global ? bind_thunk() : nullptr),
            (has_vtable && !is_global ? resource_destroyed_thunk() : nullptr),
            (has_vtable ? vtable_getter() : nullptr),
            "};"
        };
    }

private:
    Emitter constructor()
    {
        if (is_global)
            return constructor_for_global();
        else
            return constructor_for_regular();
    }

    Emitter constructor_for_global()
    {
        return Lines{
            {generated_name, "(struct wl_display* display, uint32_t max_version)"},
            {"    : global{wl_global_create(display, &", wl_name, "_interface, max_version,"},
            {"                              this, &", generated_name, "::bind_thunk)},"},
            {"      max_version{max_version}"},
            Block{
                "if (global == nullptr)",
                Block{
                    "BOOST_THROW_EXCEPTION((std::runtime_error{",
                    {"    \"Failed to export ", wl_name, " interface\"}));"}
                }
            }
        };
    }

    Emitter constructor_for_regular()
    {
        return Lines{
            {generated_name, "(struct wl_client* client, struct wl_resource* parent, uint32_t id)"},
            {"    : client{client},"},
            {"      resource{wl_resource_create(client, &", wl_name, "_interface,"},
            {"                                  wl_resource_get_version(parent), id)}"},
            Block{
                "if (resource == nullptr)",
                Block{
                    "wl_resource_post_no_memory(parent);",
                    "BOOST_THROW_EXCEPTION((std::bad_alloc{}));",
                },
                (has_vtable ?
                    "wl_resource_set_implementation(resource, get_vtable(), this, &resource_destroyed_thunk);" :
                    Emitter{nullptr})
            }
        };
    }

    Emitter destructor()
    {
        if (is_global)
        {
            return Lines{
                {"virtual ~", generated_name, "()"},
                Block{
                    "wl_global_destroy(global);"
                }
            };
        }
        else
        {
            return Lines{
                {"virtual ~", generated_name, "() = default;"}
            };
        }
    }

    Emitter bind_prototype()
    {
        return "virtual void bind(struct wl_client* client, struct wl_resource* resource) { (void)client; (void)resource; }";
    }

    Emitter virtual_method_prototypes()
    {
        std::vector<Emitter> prototypes;
        for (auto const& method : methods)
        {
            prototypes.push_back(method.virtual_mir_prototype());
        }
        return Lines{prototypes};
    }

    Emitter member_vars()
    {
        if (is_global)
        {
            return Lines{
                {"struct wl_global* const global;"},
                {"uint32_t const max_version;"},
            };
        }
        else
        {
            return Lines{
                {"struct wl_client* const client;"},
                {"struct wl_resource* const resource;"}
            };
        }
    }

    Emitter thunk_bodies()
    {
        std::vector<Emitter> bodies;
        for (auto const& method : methods)
        {
            bodies.push_back(method.thunk_body(generated_name));
        }
        return Lines{bodies};
    }

    Emitter bind_thunk()
    {
        return Lines{
            "static void bind_thunk(struct wl_client* client, void* data, uint32_t version, uint32_t id)",
            Block{
                {"auto me = static_cast<", generated_name, "*>(data);"},
                {"auto resource = wl_resource_create(client, &", wl_name, "_interface,"},
                {"                                   std::min(version, me->max_version), id);"},
                "if (resource == nullptr)",
                Block{
                    "wl_client_post_no_memory(client);",
                    "BOOST_THROW_EXCEPTION((std::bad_alloc{}));",
                },
                (has_vtable ?
                "wl_resource_set_implementation(resource, get_vtable(), me, nullptr);" :
                Emitter{nullptr}),
                "try",
                Block{
                    "me->bind(client, resource);"
                },
                "catch(...)",
                Block{{
                    "::mir::log(",
                    List{{"::mir::logging::Severity::critical",
                        "\"frontend:Wayland\"",
                        "std::current_exception()",
                        {"\"Exception processing ", generated_name, "::bind() request\""}},
                        Line{{","}, false, true}, "           "},
                        ");"
                }}
            }
        };
    }

    Emitter resource_destroyed_thunk()
    {
        return Lines{
            "static void resource_destroyed_thunk(wl_resource* resource)",
            Block{
                {"delete static_cast<", generated_name, "*>(wl_resource_get_user_data(resource));"}
            }
        };
    }

    Emitter vtable_getter()
    {
        return Lines{
            {"static inline struct ", wl_name, "_interface const* get_vtable()"},
            Block{
                {"static struct ", wl_name, "_interface const vtable = {"},
                vtable_contents(),
                "};",
                "return &vtable;"
            }
        };
    }

    Emitter vtable_contents()
    {
        std::vector<Emitter> elems;
        for (auto const& method : methods)
        {
            elems.push_back(method.vtable_initialiser());
        }
        return List{elems, Line{{","}, false, true}, Emitter::single_indent};
    }

    static std::vector<Method> get_methods(xmlpp::Element const& node, bool is_global)
    {
        std::vector<Method> methods;
        for (auto method_node : node.get_children("request"))
        {
            auto method = dynamic_cast<xmlpp::Element*>(method_node);
            methods.emplace_back(Method{std::ref(*method), is_global});
        }
        return methods;
    }

    std::string const wl_name;
    std::string const generated_name;
    bool const is_global;
    std::vector<Method> const methods;
    bool const has_vtable;
};

// arguments are:
//  0: binary
//  1: name prefix (such as wl_)
//  2: header to include (such as wayland-server.h)
//  3: input file path
int main(int argc, char** argv)
{
    if (argc != 4)
    {
        exit(1);
    }

    std::string const prefix{argv[1]};

    auto name_transform = [prefix](std::string protocol_name)
    {
        std::string transformed_name = protocol_name;
        if (protocol_name.find(prefix) == 0) // if the first instance of prefix is at the start of protocol_name
        {
            // cut off the prefix
            transformed_name = protocol_name.substr(prefix.length());
        }
        return camel_case_string(transformed_name);
    };

    std::string const input_file_path{argv[3]};
    xmlpp::DomParser parser(input_file_path);

    auto document = parser.get_document();

    auto root_node = document->get_root_node();

    auto constructor_nodes = root_node->find("//arg[@type='new_id']");
    std::unordered_set<std::string> constructible_interfaces;
    for (auto const node : constructor_nodes)
    {
        auto arg = dynamic_cast<xmlpp::Element const*>(node);
        constructible_interfaces.insert(arg->get_attribute_value("interface"));
    }

    auto emitter = emit_comment_header(input_file_path);
    emitter.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";

    std::cout << std::endl;

    std::string const include_guard_macro = macro_string("MIR_FRONTEND_WAYLAND_" + file_name_from_path(input_file_path) + "_WRAPPER");
    auto emitter0 = emit_include_guard_top(include_guard_macro);
    emitter0.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";

    std::cout << std::endl;

    std::string const custom_header{argv[2]};
    auto emitter1 = emit_required_headers(custom_header);
    emitter1.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";

    std::cout << std::endl;

    std::cout << "namespace mir" << std::endl;
    std::cout << "{" << std::endl;
    std::cout << "namespace frontend" << std::endl;
    std::cout << "{" << std::endl;
    std::cout << "namespace wayland" << std::endl;
    std::cout << "{" << std::endl;

    for (auto top_level : root_node->get_children("interface"))
    {
        auto interface = dynamic_cast<xmlpp::Element*>(top_level);

        if (interface->get_attribute_value("name") == "wl_display" ||
            interface->get_attribute_value("name") == "wl_registry")
        {
            // These are special, and don't need binding.
            continue;
        }
        auto emitter_class = Interface(*interface, name_transform, constructible_interfaces).full_class();
        emitter_class.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
        std::cout << "\n";

        std::cout << std::endl << std::endl;
    }
    std::cout << "}" << std::endl;
    std::cout << "}" << std::endl;
    std::cout << "}" << std::endl;

    std::cout << std::endl;

    auto emitter2 = emit_include_guard_bottom(include_guard_macro);
    emitter2.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";

    return 0;
}
