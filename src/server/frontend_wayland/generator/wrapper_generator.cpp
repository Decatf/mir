/*
 * Copyright © 2017 Canonical Ltd.
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 or 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored By: Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>
 */

#include "emitter.h"
#include "interface.h"
#include "utils.h"

#include <libxml++/libxml++.h>
#include <iostream>

Emitter emit_comment_header(std::string const& input_file_path)
{
    return Lines{
        "/*",
        " * AUTOGENERATED - DO NOT EDIT",
        " *",
        {" * This header is generated by wrapper_generator.cpp from ", file_name_from_path(input_file_path)},
        " * To regenerate, run the “refresh-wayland-wrapper” target.",
        " */",
    };
}

Emitter emit_include_guard_top(std::string const& macro)
{
    return Lines{
        {"#ifndef ", macro},
        {"#define ", macro},
    };
}

Emitter emit_include_guard_bottom(std::string const& macro)
{
    return Lines{
        {"#endif // ", macro}
    };
}

Emitter emit_required_headers(std::string const& custom_header)
{
    return Lines{
        "#include <experimental/optional>",
        "#include <boost/throw_exception.hpp>",
        "#include <boost/exception/diagnostic_information.hpp>",
        "",
        {"#include \"", custom_header, "\""},
        "",
        "#include \"mir/fd.h\"",
        "#include \"mir/log.h\"",
    };
}

void emit_indented_lines(std::ostream& out, std::string const& indent,
                         std::initializer_list<std::initializer_list<std::string>> lines)
{
    for (auto const& line : lines)
    {
        out << indent;
        for (auto const& fragment : line)
        {
            out << fragment;
        }
        out << "\n";
    }
}

// arguments are:
//  0: binary
//  1: name prefix (such as wl_)
//  2: header to include (such as wayland-server.h)
//  3: input file path
int main(int argc, char** argv)
{
    if (argc != 4)
    {
        exit(1);
    }

    std::string const prefix{argv[1]};

    auto name_transform = [prefix](std::string protocol_name)
    {
        std::string transformed_name = protocol_name;
        if (protocol_name.find(prefix) == 0) // if the first instance of prefix is at the start of protocol_name
        {
            // cut off the prefix
            transformed_name = protocol_name.substr(prefix.length());
        }
        return to_camel_case(transformed_name);
    };

    std::string const input_file_path{argv[3]};
    xmlpp::DomParser parser(input_file_path);

    auto document = parser.get_document();

    auto root_node = document->get_root_node();

    auto constructor_nodes = root_node->find("//arg[@type='new_id']");
    std::unordered_set<std::string> constructible_interfaces;
    for (auto const node : constructor_nodes)
    {
        auto arg = dynamic_cast<xmlpp::Element const*>(node);
        constructible_interfaces.insert(arg->get_attribute_value("interface"));
    }

    auto emitter = emit_comment_header(input_file_path);
    emitter.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";

    std::cout << std::endl;

    std::string const include_guard_macro = to_upper_case("MIR_FRONTEND_WAYLAND_" + file_name_from_path(input_file_path) + "_WRAPPER");
    auto emitter0 = emit_include_guard_top(include_guard_macro);
    emitter0.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";

    std::cout << std::endl;

    std::string const custom_header{argv[2]};
    auto emitter1 = emit_required_headers(custom_header);
    emitter1.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";

    std::cout << std::endl;

    std::cout << "namespace mir" << std::endl;
    std::cout << "{" << std::endl;
    std::cout << "namespace frontend" << std::endl;
    std::cout << "{" << std::endl;
    std::cout << "namespace wayland" << std::endl;
    std::cout << "{" << std::endl;

    for (auto top_level : root_node->get_children("interface"))
    {
        auto interface = dynamic_cast<xmlpp::Element*>(top_level);

        if (interface->get_attribute_value("name") == "wl_display" ||
            interface->get_attribute_value("name") == "wl_registry")
        {
            // These are special, and don't need binding.
            continue;
        }
        auto emitter_class = Interface(*interface, name_transform, constructible_interfaces).full_class();
        emitter_class.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
        std::cout << "\n";

        std::cout << std::endl << std::endl;
    }
    std::cout << "}" << std::endl;
    std::cout << "}" << std::endl;
    std::cout << "}" << std::endl;

    std::cout << std::endl;

    auto emitter2 = emit_include_guard_bottom(include_guard_macro);
    emitter2.emit({std::cout, std::make_shared<bool>(false), "\t\t"});
    std::cout << "\n";
}
